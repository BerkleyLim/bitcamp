// 정수의 리터럴 4번째 - 메모리에 저장하는 방법
package step01;
public class Exam05_4 {
    public static void main(String[] args) {
        System.out.println(2147483647); // 4바이트 양의 정수 최대값
        System.out.println(-2147483648); // 4바이트 음의 정수 최솟값

    }
}

// <정수를 2진수로 표현 방법>
// 1) 부호-크기/절대값
//  - 맨 왼쪽 1비트를 부호비트 (양수 '0', 음수 '1')
//  - 나머지 비트 : 절대값으로 저장 (예 : 8비트 = 1비트(부호) + 7비트(절대값))
//  - 수의 범위(8비트 기준) : -127 ~ +127
//  - 문제점
//    => 두 개의 0(+0, -0)이 존재
//    => 양수와 음수를 더하면, 옳지 않은 값 존재.
//      0001(+1) + 1001(-1) = 1010 (-2)  <-- 계산 결과가 옳지 않음
//    => 음수와 양수를 더하는 컴퓨팅 회로를 별도로 설계해야 해서 H/W 가 복잡
//  - 장점 : 이해 쉬움
//  - 용도 : 부동 소수점에서 가수부를 표현할 때

// 2) 1의 보수
//  - 모든 비트를 반대 값으로 바꿈
//   8비트 사용한다고 가정하고, +24와 -24를 표현
//     +24 : 0001 1000
//     -24 : 1110 0111
//  - 수의 범위(8비트 기준) : -127 ~ +127
//  - 문제점 : 두 개의 0(+0, -0)이 존재
//          두 수를 더한 후 비트 크기를 초과한 1값을 다시 맨 뒤에 더해야 함

// 3) 2의 보수
//  - 1의 보수 문제점을 위해 등장!
//  - 음수 0을 없애서 -128까지 표현 가능
//  - 장점 : 양수와 음수의 덧셈 가능
//          음수 0 없고, 0에 대한 표현이 한 가지

// 4) K-초과(Excess-K)
// 