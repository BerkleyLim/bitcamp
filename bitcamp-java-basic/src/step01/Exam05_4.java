// 정수의 리터럴 4번째 - 메모리에 저장하는 방법
package step01;
public class Exam05_4 {
    public static void main(String[] args) {
        System.out.println(5 - 3); 
        System.out.println(5 + (-3));

    }
}  // <결론> 
//  => 자바에서는 정수를 저장 시 2의 보수 방법을 사용
//  => 부동소수점을 저장할 때는
//     가수부는 'Sign-Magnitude 방식'으로 저장하고,
//     지수부는 'Excess-K 방식'으로 저장한다.

// <정수를 2진수로 표현 방법>
// 1) 부호-크기/절대값
//  - 맨 왼쪽 1비트를 부호비트 (양수 '0', 음수 '1')
//  - 나머지 비트 : 절대값으로 저장 (예 : 8비트 = 1비트(부호) + 7비트(절대값))
//  - 수의 범위(8비트 기준) : -127 ~ +127
//  - 문제점
//    => 두 개의 0(+0, -0)이 존재
//    => 양수와 음수를 더하면, 옳지 않은 값 존재.
//      0001(+1) + 1001(-1) = 1010 (-2)  <-- 계산 결과가 옳지 않음
//    => 음수와 양수를 더하는 컴퓨팅 회로를 별도로 설계해야 해서 H/W 가 복잡
//  - 장점 : 이해 쉬움
//  - 용도 : 부동 소수점에서 가수부를 표현할 때

// 2) 1의 보수
//  - 모든 비트를 반대 값으로 바꿈
//   8비트 사용한다고 가정하고, +24와 -24를 표현
//     +24 : 0001 1000
//     -24 : 1110 0111
//  - 수의 범위(8비트 기준) : -127 ~ +127
//  - 문제점 : 두 개의 0(+0, -0)이 존재
//          두 수를 더한 후 비트 크기를 초과한 1값을 다시 맨 뒤에 더해야 함

// 3) 2의 보수
//  - 1의 보수 문제점을 위해 등장!
//  - 음수 0을 없애서 -128까지 표현 가능
//  - 장점 : 양수와 음수의 덧셈 가능
//          음수 0 없고, 0에 대한 표현이 한 가지

// 4) K-초과(Excess-K)
//  - offset binary 또는 바이어스 표기법이라고도 함
//  - K를 바이어스 값, 표현할 때의 값에 더할 때 사용
//  - K = 2^(비트수 - 1) - 1
//  - 8비트시 : K = 2^7 -1 = 127, 결과 = 127 + 값
//      1111 1111 = 127 + 128
//      1111 1110 = 127 + 127

//      1000 0000 = 127 + 1
//      0111 1111 = 127 + 0

//      0000 0010 = 127 + (-125)

//  - 수의 범위 : -128 ~ +127

